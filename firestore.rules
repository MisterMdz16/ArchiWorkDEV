rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for authentication and authorization
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    function getUserData(uid) {
      return get(/databases/$(database)/documents/users/$(uid)).data;
    }
    
    function isAdmin() {
      return isAuthenticated() && getUserData(request.auth.uid).user_type == 'admin';
    }
    
    function isDesignerVerified() {
      return isAuthenticated() &&
             getUserData(request.auth.uid).user_type == 'designer' &&
             getUserData(request.auth.uid).designer_verification_status == 'verified';
    }
    
    function isDesignerUnverified() {
      return isAuthenticated() &&
             getUserData(request.auth.uid).user_type == 'designer' &&
             getUserData(request.auth.uid).designer_verification_status == 'unverified';
    }
    
    function isDesigner() {
      return isAuthenticated() && getUserData(request.auth.uid).user_type == 'designer';
    }
    
    function isServiceRequester() {
      return isAuthenticated() && 
             getUserData(request.auth.uid).user_type == 'service_requester';
    }
    
    function isValidUserType(userType) {
      return userType in ['admin', 'designer', 'service_requester'];
    }
    
    function isValidDesignerVerificationStatus(status) {
      return status == null || status in ['verified', 'unverified'];
    }
    
    // Users collection rules - Core security for user profiles
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    
      // READ RULES
      // Users can read their own profile
      // Admins can read all profiles
      // Service requesters can read verified designer profiles
      // Verified designers can read other verified designer profiles
      allow read: if isOwner(userId) 
                  || isAdmin()
                  || (isServiceRequester() &&
                      resource.data.user_type == 'designer' &&
                      resource.data.designer_verification_status == 'verified')
                  || (isDesignerVerified() &&
                      resource.data.user_type == 'designer');
      
      // CREATE RULES
      // Users can create their own profile during registration
      // Must use their own UID and email from auth token
      // User type must be valid
      // Designer verification status must be consistent with user type
      allow create: if isOwner(userId) 
                    && resource.data.uid == userId
                    && resource.data.email == request.auth.token.email
                    && isValidUserType(resource.data.user_type)
                    && isValidDesignerVerificationStatus(resource.data.designer_verification_status)
                    // Ensure designer verification status aligns with user type
                    && ((resource.data.user_type == 'designer' && resource.data.designer_verification_status in ['verified', 'unverified'])
                        || (resource.data.user_type in ['admin', 'service_requester'] && (resource.data.designer_verification_status == null || !('designer_verification_status' in resource.data))))
                    // Only admins can create admin accounts
                    && (resource.data.user_type != 'admin' || isAdmin())
                    // New users must be active
                    && resource.data.is_active == true;
      
      // UPDATE RULES
      // Users can update their own profile (limited fields)
      // Admins can update any profile including sensitive fields
      allow update: if isOwner(userId) && (
                      // Regular users can update these fields only
                      resource.data.diff(resource.data).affectedKeys().hasOnly(['full_name', 'updated_at'])
                    )
                    || isAdmin() && (
                      // Admins can update all fields but must maintain data integrity
                      isValidUserType(resource.data.user_type) &&
                      isValidDesignerVerificationStatus(resource.data.designer_verification_status) &&
                      // Ensure consistency between user_type and designer_verification_status
                      ((resource.data.user_type == 'designer' && resource.data.designer_verification_status in ['verified', 'unverified'])
                       || (resource.data.user_type in ['admin', 'service_requester'] && (resource.data.designer_verification_status == null || !('designer_verification_status' in resource.data))))
                    );
      
      // DELETE RULES
      // Only admins can delete user profiles
      allow delete: if isAdmin();
    }
    
    // Projects collection rules (example for future implementation)
    match /projects/{projectId} {
      // READ: Project visibility based on status and ownership
      allow read: if isAuthenticated() && (
                    // Public projects visible to all authenticated users
                    resource.data.visibility == 'public'
                    // Private projects visible to owner and collaborators
                    || resource.data.owner_uid == request.auth.uid
                    || request.auth.uid in resource.data.collaborator_uids
                    // Admins can see all projects
                    || isAdmin()
                  );
      
      // CREATE: Designers and admins can create projects
      allow create: if isAuthenticated() && (
                      isDesigner() || isAdmin()
                    ) && resource.data.owner_uid == request.auth.uid;
      
      // UPDATE: Project owner, collaborators, and admins can update
      allow update: if isAuthenticated() && (
                      resource.data.owner_uid == request.auth.uid
                      || request.auth.uid in resource.data.collaborator_uids
                      || isAdmin()
                    );
      
      // DELETE: Only project owner and admins can delete
      allow delete: if isAuthenticated() && (
                      resource.data.owner_uid == request.auth.uid
                      || isAdmin()
                    );
    }
    
    // Messages/Communications collection (example for future implementation)
    match /conversations/{conversationId} {
      allow read, write: if isAuthenticated() && (
                           request.auth.uid in resource.data.participant_uids
                           || isAdmin()
                         );
      
      match /messages/{messageId} {
        allow read: if isAuthenticated() && (
                      request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participant_uids
                      || isAdmin()
                    );
        
        allow create: if isAuthenticated() && 
                      request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participant_uids &&
                      resource.data.sender_uid == request.auth.uid;
        
        allow update, delete: if isAuthenticated() && (
                                resource.data.sender_uid == request.auth.uid
                                || isAdmin()
                              );
      }
    }
    
    // Portfolio collection (for designer profiles)
    match /portfolios/{portfolioId} {
      // READ: Portfolios are publicly readable for discovery
      allow read: if isAuthenticated();
      
      // CREATE: Only verified designers can create portfolios
      allow create: if isAuthenticated() && 
                    isDesignerVerified() &&
                    resource.data.designer_uid == request.auth.uid;
      
      // UPDATE: Portfolio owner and admins can update
      allow update: if isAuthenticated() && (
                      resource.data.designer_uid == request.auth.uid
                      || isAdmin()
                    );
      
      // DELETE: Portfolio owner and admins can delete
      allow delete: if isAuthenticated() && (
                      resource.data.designer_uid == request.auth.uid
                      || isAdmin()
                    );
    }
    
    // Reviews collection (for designer ratings)
    match /reviews/{reviewId} {
      // READ: Reviews are publicly readable
      allow read: if isAuthenticated();
      
      // CREATE: Only service requesters can create reviews
      allow create: if isAuthenticated() && 
                    isServiceRequester() &&
                    resource.data.reviewer_uid == request.auth.uid;
      
      // UPDATE: Review author and admins can update
      allow update: if isAuthenticated() && (
                      resource.data.reviewer_uid == request.auth.uid
                      || isAdmin()
                    );
      
      // DELETE: Review author and admins can delete
      allow delete: if isAuthenticated() && (
                      resource.data.reviewer_uid == request.auth.uid
                      || isAdmin()
                    );
    }
    
    // Notifications collection
    match /notifications/{notificationId} {
      // Users can only access their own notifications
      allow read, update, delete: if isAuthenticated() && 
                                   resource.data.recipient_uid == request.auth.uid;
      
      // System/admin can create notifications
      allow create: if isAdmin();
    }
    
    // Allow analytics collection access
    match /analytics/{document} {
      allow read, write: if request.auth != null;
    }
    
    // Projects collection (for future implementation)
    match /projects/{projectId} {
      // READ: Project visibility based on status and ownership
      allow read: if isAuthenticated() && (
                    // Public projects visible to all authenticated users
                    resource.data.visibility == 'public'
                    // Private projects visible to owner and collaborators
                    || resource.data.owner_uid == request.auth.uid
                    || request.auth.uid in resource.data.collaborator_uids
                    // Admins can see all projects
                    || isAdmin()
                  );
      
      // CREATE: Designers and admins can create projects
      allow create: if isAuthenticated() && (
                      isDesigner() || isAdmin()
                    ) && resource.data.owner_uid == request.auth.uid;
      
      // UPDATE: Project owner, collaborators, and admins can update
      allow update: if isAuthenticated() && (
                      resource.data.owner_uid == request.auth.uid
                      || request.auth.uid in resource.data.collaborator_uids
                      || isAdmin()
                    );
      
      // DELETE: Only project owner and admins can delete
      allow delete: if isAuthenticated() && (
                      resource.data.owner_uid == request.auth.uid
                      || isAdmin()
                    );
    }
    
    // Verification requests collection - for designer verification submissions
    match /verification_requests/{requestId} {
      // Users can create their own verification requests
      allow create: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
      
      // Users can read their own verification requests
      // Admins can read all verification requests
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      
      // Only admins can update verification requests (for approval/rejection)
      allow update: if isAdmin();
      
      // Only admins can delete verification requests
      allow delete: if isAdmin();
    }
    
    // System messages collection - for automated notifications
    match /system_messages/{messageId} {
      // Users can read their own system messages
      // Admins can read all system messages
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      
      // Only admins and system can create/update system messages
      allow create, update: if isAdmin();
    }
    
    // User messages collection - for admin-user communication
    match /user_messages/{messageId} {
      // Users can read their own messages
      // Admins can read all messages
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      
      // Users can create messages to admins
      // Admins can create messages to users
      allow create: if isAuthenticated() && (
        (resource.data.userId == request.auth.uid && !resource.data.isFromAdmin) ||
        isAdmin()
      );
      
      // Only admins can update messages
      allow update: if isAdmin();
    }

    match /system/{document=**} {
      allow read, write: if isAdmin();
    }
    
    // Default deny rule for any other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

/*
SECURITY RULES EXPLANATION:

1. USER PROFILE SECURITY:
   - Users can only read/write their own profiles
   - Admins have elevated access to all profiles
   - Service requesters can browse verified designer profiles
   - Profile creation requires proper authentication and validation

2. ROLE-BASED ACCESS:
   - Admin: Full access to all collections
   - Designer (Verified): Can create projects, portfolios, read other verified designers
   - Designer (Unverified): Limited access, cannot create public content
   - Service Requester: Can browse designers, create reviews, request services

3. DATA INTEGRITY:
   - User types are validated against allowed values
   - Designer verification status must align with user type
   - Email consistency enforced between Auth and Firestore
   - Timestamps automatically managed

4. PRIVACY PROTECTION:
   - Users cannot access other users' private data
   - Conversations restricted to participants
   - Notifications restricted to recipients

5. AUDIT TRAIL:
   - All updates include timestamps
   - Critical operations logged
   - Admin actions trackable

These rules provide a solid foundation for a secure, role-based architecture
while maintaining flexibility for future features.
*/// Your path looks good: verification/tAfoEHITaoeQ0TyfUHtBuWNx2yi2/national_id_1754146233653_Metio.jpg
const uploadPath = `verification/${userId}/${documentType}_${timestamp}_${file.name}`;
